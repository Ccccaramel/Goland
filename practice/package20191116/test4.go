package main

import "fmt"

func main() {
	ch1 := make(chan int, 2) // 为什么指定的容量是2但实际却能 send 4个值?另外即使不声明容量(即默认容量为0)也不会阻塞?
	// 发送方
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Printf("Sender: sending element %v...\n", i)
			ch1 <- i
		}
		fmt.Println("Sender: close the channel...")
		close(ch1)
	}()

	// 接收方
	for {
		elem, ok := <-ch1
		if !ok {
			fmt.Println("Receiver: closed channel")
			break
		}
		fmt.Printf("Receiver: received an element: %v\n", elem)
	}
	fmt.Println("End,")
}

/*
通道(channel)
	通道类型是 Go 自带的,相当于是一个先进先出的队列,同时唯一一个可以满足并发安全性的类型
	声明一个通道类型变量的时候,首先需要确定通道类型的元素类型,然后还要确定通道的容量
	当然默认容量是0

初始化
	c := make(chan int)
	c := make(chan string, 10)
	如果不指定容量即默认容量是0,这种通道称为非缓冲通道

通道的发送和接收特性
	1.对于同一个通道,发送操作之间是互斥的,接受操作之间也是互斥的
		简单来说就是在同一时刻, Go 的运行系统只会执行对同一个通道的任意个发送操作中的某一个
		直到这个元素值被完全复制进该通道后,其它发送操作才会执行,针对接收操作也是这样
		对于通道中的同一个值,发送操作和接受操作也是互斥的,如正在被复制进通道但还未复制完成的元素值
		这时接收方也不会看到和取走
		tips:元素值从外界进入通道会被复制,也就是说进入通道的并不是在接收操作符右边的那个元素值,而是它的副本
	2.发送操作和接收操作中对元素值的处理都是不可分割的
		不可分割的意思是发送操作要么还没复制元素,要么已复制完毕,不会出现值只复制了一部分的情况
	3.发送操作在完全完成之前会被阻塞,接收亦是如此
		发送操作包括"复制元素值","放置副本到通道内"二个步骤,在这二个步骤完成之前,发送操作会一直阻塞,它之后的代码是不会执行的
		接收操作包括"复制通道内元素值","放置副本到接收方","删除原值"三个操作,这三个操作在完成之前也是会一直阻塞的
		tips:上面讲的复制都属于浅拷贝, Golang 只有浅拷贝

发送操作和接收操作在什么情况下会被阻塞呢?
	对于缓存通道:
		1.如果通道已满,所有的发送操作就会阻塞,直到通道中有元素被取走
		2.如果通道已空,所有的接收操作就会阻塞,直到通道中有新的元素
	对于非缓存通道:
		1.无论发送操作还是接收操作一开始就是阻塞的,只有配对的操作出现才会开始执行

收发操作何时会引起 panic
	1.通道关闭,在进行发送操作会引起 panic
	2.关闭一个已经关闭的通道也会引发 panic
		更具体地说,当我们把接收表达式的结果同时赋给两个变量时,第二个变量的类型就一定是 bool 类型
		它的值如果为 false 就说明通道已经关闭,并且再也没有元素值可取了
		注意:如果通道关闭时,里面还有元素值未被取出,那么接收表达式的第一个结果,仍会是通道中的某一个元素值
			而第二个结果值一定会是 true ,因此通过接收表达式的第二格结果值来判断通道是否关闭是可能有延迟的

Channel 引起的死锁的常见场景
	死锁是指两个或两个以上的协程的执行过程中,由于竞争资源或由于彼此通信而造成的一种阻塞的现象,若无外力作用
	它将无法推进下去,解决死锁的方法是加锁
	场景一:一个通道在一个 go 协程读写
		func main(){
			c := make(chan int)
			c <- 666
			<- c
		}
	场景二: go 程开启之前使用通道
		func main(){
			c := make(chan int)
			c <- 666
			go func(){
				<- c
			}()
		}
	场景三:通道1中调用了通道2,通道2中调用了通道1
		func main(){
			c1, c2 := make(chan int), make(chan int)
			go func(){
				for{
					selecet{
						case <- c1:
							c2 <- 10
					}
				}
			}()
			for{
				select{
					case <- c2:
						c1 <- 10
				}
			}
		}
*/
